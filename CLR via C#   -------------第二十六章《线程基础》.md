CLR via C#   -------------第二十六章《线程基础》
========================================
##第二十六章                《泛型》

 - windows为什么要支持线程
 - 线程开销
 - 停止疯狂
 - CPU发展趋势
 - CLR线程和Windows线程
 - 使用专用线程执行异步的计算限制操作
 - 使用线程的理由
 - 线程调度和优先级
 - 前台线程和后台线程

###26.1 windows为什么要支持线程
```当操作系统没有线程的概念的时候，整个计算机只运行一个**执行线程**（单核CPU），其中包括了操作系统和各种应用代码，一旦一个长时间运行的程序占用了线程，或者应用程序产生Bug开始了无限死循环，那整个机器就会被冻结，这个时候，网管都会过来告诉你，重启一下就好了，这不是没有道理！```
```
这个时候微软想了个办法，那就是决定在一个进程中，执行多个线程，进程就相当于工厂的车间一样，是线程（人）使用资源的集合，既然是车间肯定就需要分配虚拟地址空间。这样就确保了其他的进程无法使用该进程的代码和数据。下面采用图文并茂的方式来描述一下线程和进程的关系:
```
**1. 计算机的核心是CPU，它承担了所有的计算任务，它就像一座工厂，时刻在运行**
![此处输入图片的描述][1]


  **2. 由于该工厂的电力有限，一次只能给工厂的一个车间供电，一个车间开工的时候，所有车间都要停工，背后的含义就是26.1的第一段话，单核CPU一次只能运行一个任务。**![此处输入图片的描述][2]
  **3. 进程就好比工厂的车间，它代表CPU所能处理的单个任务。车间的种类分工各有不同，但是如上所说，因为电量不足，所以该效率底下的工厂总是只能运行一个车间**
  ![此处输入图片的描述][3]
  **4. 一个车间里，可以有很多人，他们同时执行的同一个任务**![此处输入图片的描述][4]
  **5. 线程就好比车间里的工人，一个车间可以有多个工人，就好像一个进程可以有多个线程一样**![此处输入图片的描述][5]
  **6. 每一个车间的地方都是共享的，这意味着所有的工人都可以自由的进出，就好像每一个进程的虚拟地址空间是共享的，每个线程都可以使用这些**![此处输入图片的描述][6]
  **7. 可是，每间房间的大小不同，容纳的人也不同，就好比厕所一样，一旦有人占着茅坑，其他人就得等他拉完屎了，这就好像一个线程占用了某个内存地址，其他线程就乖乖等着吧**![此处输入图片的描述][7]
  **8. 当然了，有的地方特别的抢手，就好像图7的厕所，计算机有一个防止别人进入的简单方法，就是给工人配一把锁，当多个工人抢厕所的时候，允许一个工人去上厕所，然后把门锁上，防止你上厕所上着上着有人就推门进来了。这就好像计算机中的“互斥锁”，防止多个线程同时读写某一块内存地址**![此处输入图片的描述][8]
  **9. 操作系统的设计，可以归结为三点：

 1. 以多进程的形式，允许多个任务同时执行（多个工厂）
 2. 以多线程的形式，允许单个任务被多个线程运行（一个车间完成的工作量由多个工人共同完成）
 3. 提供协调机制，比如“互斥锁”，一方面防止进程之间和线程之间产生冲突，另一方面允许进程和线程共享CPU资源![此处输入图片的描述][9]
**
###26.2 线程开销
线程比作工人，就需要给工人工作环境和支配工资，所以线程务必会占用进程的虚拟内存地址和执行性能上的开销。

###26.3 停止疯狂
如果只关心线程，那么机器最优的线程数就是该机器的CPU数，比如四核CPU最优的就是每个进程里面有四个线程，Windows默认给每个线程分配线程栈的内存是1M，现在打开任务管理器，你可以看看你的RAM是不是早就不够用了

###26.4 CPU发展趋势
谁都知道，如果一个进程可以有多个线程（每个线程其实都分配了CPU内核，就相当于一个虚拟CPU）来执行，那速度一定很快。就好像一个车间，多加几个工人来完成车间工作，时间一定会更快，所以在更新迭代的计算机领域，都是由：

 - 多个CPU
 给一个计算机安装多个CPU，就是在机箱上多插几个CPU，但是这样主板也要求更大，机箱也会更大，所以其体积和价格都不理想
 
 - 超线程芯片
 我的理解是超线程芯片其实是假的双核芯片，在Windows上，看起来就像是安装了两个CPU一样，但芯片每次都只能执行一个线程。并不是两个线程同时并发运行的，Windows先只运行一个线程，然后在忙里偷闲，去运行其他的线程
 
 
 - 多核芯片
 广为使用的八核芯片说的就是这个东西，八核，八个CPU，每个车间的空间更大，一下可以容纳8个工人来共同完成该车间任务
 
 ###26.5 CLR线程和Windows线程
略
###26.6 使用专用线程执行异步操作的计算限制操作
```
//构造thread对象
class ThreadTest 
{
  static void Main() {
    Thread t = new Thread (WriteY);
    t.Start();                          // Run WriteY on the new thread
    while (true) Console.Write ("x");   // Write 'x' forever
  }
  
  static void WriteY() {
    while (true) Console.Write ("y");   // Write 'y' forever
  }
}
```

###26.7 使用线程的理由

 - 可响应性（对于图形化应用程序）
 灵敏的响应用户想要执行的Button操作，是因为使用了独立的线程来完成该操作
 
 - 性能（对于客户端和服务器应用程序）
 同时执行多个操作性能能不好么，废话~
 
 ###26.8 线程调度和优先级
 略
 
 ###26.9前台线程和后台线程
 应用程序：必须运行完所有的前台程序才可以退出，一般都是主线程（尽量避免使用）
 后台程序：不考虑是否已经运行完毕就可以直接退出
 ```
public static void myStaticThreadMethod()
{
    Thread.Sleep(3000);
}
Thread thread = new Thread(myStaticThreadMethod);
// thread.IsBackground = true;//注释去掉，因为没有前台线程的存在，程序会立即退出！
thread.Start()
```

 

  [1]: http://image.beekka.com/blog/201304/bg2013042401.jpg
  [2]: http://image.beekka.com/blog/201304/bg2013042402.png
  [3]: http://image.beekka.com/blog/201304/bg2013042403.jpg
  [4]: http://image.beekka.com/blog/201304/bg2013042404.jpg
  [5]: http://image.beekka.com/blog/201304/bg2013042405.jpg
  [6]: http://image.beekka.com/blog/201304/bg2013042406.png
  [7]: http://image.beekka.com/blog/201304/bg2013042407.jpg
  [8]: http://image.beekka.com/blog/201304/bg2013042408.jpg
  [9]: http://image.beekka.com/blog/201304/bg2013042411.png