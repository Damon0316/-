CLR via C#   -------------第六章《类型和成员基础》#
========================================
##第六章                《类型和成员基础》

 - 类型的各种成员
 - 类型的可见性
 - 成员的可访问性
 - 静态类
 - 分布类、结构和接口
 - 组件、多态和版本控制

###6.1 类型的各种成员
类的成员有：

 - 常量：数值恒定不变的符号
 - 字段：只读或者只读/可写的数据值
 - 实例构造器：土话说的构造函数，给新对象一个良好的初始化的方法
 - 类型构造器：将静态对象一个良好的初始化的方法
 - 方法：更改或查询数据类型或对象状态的函数
 - 属性：
 - 事件：
 - 类型：就是类，非要整个类型类型，看的我累死！

<i class="icon-file"></i>在初学C#的时候，一定会有疑惑，为什么一个程序可以容纳不同的编程语言呢，这里就能体现元数据的强大了，这是因为编译器会将源代码统一编译成CLR能识别的元数据，而元数据的格式又是完全一致的，这样就能无缝链接另一个编程语言的代码了。

###6.2 类型的可见性

 1. internal ：当前程序集可见
 2. public ：所有程序集可见

<i class="icon-file"></i>友元程序集：没用到过，大致就是在引用一个命名空间之后，用它里面的一个方法，然后添加公钥，这样在该类中即使不讲类型指定为public，在别的程序集中同样可以使用该类的所有internal类和成员

###6.3 成员的可访问性
|CLR术语|C#|描述|
|-------|-----|--|
|Private|private|只能有当前类或者嵌套类使用|
|Family|protected|只能由当前类或者当前程序集的派生类使用|
|Assembly|internal|当前程序集可以使用|
|Public|public|任何程序集都可以使用|
<i class="icon-file"></i>在C#中，类的成员默认是private的，而接口的成员默认是public的。
派生类型重写基类类型的时候需要保证，重写成员和基类成员的访问限制要一致。

###6.4 静态类
<i class="icon-file"></i>这是一个不需要实例化的特殊类，是直接从System.Object派生的类，因为它不需要实例化，因此该类就有很多因为不能实例化而产生的很多不一样的地方：

 - 静态类是必须被static加以限制的，这毋庸置疑
 - 静态类的成员，方法，事件等等都必须被必须是static的
 - 是没有办法调用接口的

###6.5 分布类、结构、接口
很少有使用到partial关键字，所以这里不做解释

###6.6 组件、多台和版本控制
|C#关键字|方法\属性\事件|
|--------|---------------|
|abstract|类里的成员必须被重写|
|virtual|可以被重写的定义关键字|
|override|确定来重写的派生类的关键字|
|sealed|规定不能被重写的关键字|

<i class="icon-file"></i>归论正章，建议今后在定义已经明确了不会被重写的类都加上sealed关键字，调用虚方法在性能上是不及非虚方法的，虚方法需要默认去查找类对象的类型

<i class="icon-file"></i>有个很关键的关键字区别，new是替代原有的方法，之后调用方法的时候，都会调用被new关键字修饰过的方法，而override可以理解成重写，可以在方法里面添加或者要删除的代码，并且可以选择用base来调用基类原始的方法。

