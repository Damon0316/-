CLR via C#   -------------第五章《基元类型、引用类型、值类型》#
========================================
##第五章                《基元类型、引用类型、值类型》

 - 编程语言的基元类型
 - 引用类型和值类型
 - 值类型的装箱拆箱
 - 对象哈希吗
 - dynamic基元类型

###5.1  编程语言的基元类型
编译器直接支持的数据类型，在这里称之为基元类型，因为CLR对基元类型足够的了解，所以在执行对基元类型的对象的操作的时候，会比其余类型更加的迅速。
![此处输入图片的描述][1]


  [1]: http://img.educity.cn/img_5/127/2013102518/1976185456.jpg
  在上表中，基元类型都是有对象FCL类型的，所以我们纠结string和String的时候就没有道理了，string会自动映射成FCL类型的String，所以两者是一样一样的
  
###5.1.1checked和unchecked
对基元类型的操纵是很容易造成数据溢出的。下面是一个简单的checked检查块
```
checked
{
byte b = 100;
byte b = (byte)(b+200);//程序会进行溢出检查
}
```

###5.2  引用类型和值类型
<i class="icon-lightbulb"></i>在潜意识里，引用类型和值类型的最大的区别在于一个是在堆上分配，一个是在栈上分配，这样在传递值的时候，一个是复制指针（一变都变），一个是复制值（后变前不变）。
<i class="icon-lightbulb"></i>其实，在多数的公司里，是很少用到值类型（enum，strut）的，因为公司根本不在乎这一丁点的性能损耗，所以不再过多的赘述。

###5.3 值类型的装箱和拆箱
<i class="icon-lightbulb"></i>装箱：
很多时候我们需要对值类型添加引用，比如做的第一个项目的返回页面total值，显然要时时获取最新的total值，必然需要对值类型total进行装箱操作。一旦进行装箱操作，就会给值类型分配堆地址，这样一来，值类型就成了引用类型
<i class="icon-lightbulb"></i>拆箱：
没什么好说的，引用类型转成值类型就完成了拆箱操作如
```
Int32 v = 5;
object o = v;
v = 123;
Console.WriteLine(v + "," +(Int32) O)//一共进行了三次装箱操作一次拆箱操作，如果感到意外，重新翻一遍本章书籍
```

###5.4  对象哈希码
<i class="icon-lightbulb"></i>对于Equals方法和GetHashCode方法，考虑在项目中运用的过少，这里也不在研究，在后续如果有机会进行补充。

###5.4  dynamic基元类型
同上
